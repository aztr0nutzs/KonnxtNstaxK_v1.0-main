Title: Project Rules – Cyberpunk Camera Android AppScope and goalsThis project is a cyberpunk‑style Android app for viewing and managing multiple camera sources: local device cameras, IP cameras (RTSP/ONVIF), and USB/UVC cameras. �����The app must provide:A dark black UI with neon purple and cyan accents.A clean, feature‑rich dashboard for viewing multiple streams.Extensive camera configuration options and robust streaming.AI assistant behavior rulesThe AI must:Be thorough and explicit in every response.Double‑check all code, imports, and configurations before presenting them.Avoid vague statements; always show concrete examples.Clearly list which files to create, edit, or delete.Keep explanations short but precise when not requested otherwise.The AI must always assume:Full read/write access to all project files in this repository.Full Git access, including the ability to:Propose branches and meaningful commit messages.Propose sequences of commits for major features.The AI must:Respect and keep this project’s color scheme and design language.Maintain consistent package naming and module boundaries.Avoid dead code and unused dependencies when possible.Prefer idiomatic Kotlin and modern Android practices (Compose, coroutines, etc.). ���Tech stack rulesLanguage: Kotlin only for production code.UI: Jetpack Compose as the primary UI toolkit. �DI: Use a simple DI approach (e.g., Hilt or manual) as appropriate.Camera handling:Local camera: CameraX for preview, capture, and controls. ��IP cameras:Use Media3/ExoPlayer with RTSP support as primary. ��Design for future ONVIF and HLS/RTMP support. ��USB/UVC:Use a proven UVC library that supports non‑rooted Android and multiple cameras, such as AndroidUSBCamera or UVCAndroid. ����Architecture:MVVM or MVI pattern with ViewModels and repositories.Coroutines and Flow for async operations and state updates.UI and UX rulesColor scheme:Background: pure or near‑pure black.Primary accent: vivid neon purple.Secondary accent: bright cyan.Style:Clean, high‑contrast cyberpunk feel.Minimal but bold UI components.Avoid clutter and excessive text on any single screen.Screens:Dashboard with multiple camera tiles and quick controls.Detail view for a single camera with full controls.Configuration screens for:Adding/editing IP cameras.Managing USB cameras.Configuring local camera settings.Global app settings: theme intensity, default layouts, defaults for stream quality, etc.Camera configuration and capabilitiesEach camera source (local/IP/USB) should have:Name, type (local/IP/USB), tags.Connection parameters (URL, IP, port, credentials, protocol).Desired resolution and frame rate where supported.Quality presets (low/medium/high).Auto‑reconnect behavior: delay, retry count, backoff strategy. ��Handle:Connection errors with clear messages.Network interruptions with automatic retries.Optional logging of technical error details, but never credentials.Networking and securityAlways:Store credentials securely where possible.Avoid printing or logging passwords, tokens, or full RTSP URLs with credentials. ��Design with:Basic authentication flows for IP cameras (username/password).Option to use HTTPS/secure endpoints when applicable. ��Git and workflow rulesFor each logical feature or fix, the AI should:Propose a short branch name (e.g., feature/ip-camera-rtsp-support).Suggest clear commit messages that describe changes.When making larger refactors, the AI should:Explain the motivation.Propose incremental commits rather than one giant change.Quality and validationThe AI must:Check code for syntax errors and obvious logical mistakes.Ensure Gradle builds are consistent and dependencies compile conceptually. ���Add basic tests or at least structure to support future tests where reasonable.When unsure:The AI must explain trade‑offs and recommend a default choice.